##rectCover 2016.12.20

#### 题目十一: ####

> 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。比如9的二进制位1001，有2位是1.因此输出2。

#### 解答（C++）常规解法:32位整数需要循环32次

    class Solution {
    public:
     int  NumberOf1(int n) {
		 int count=0;
		 unsigned int flag=1;
		 while(flag)
		 {
			if(n & flag)//判断n的最低位是不是1->次低位是不是1->....
				count++;
			flag=flag<<1;//左移一位，1->2->4...
		 }
		 return count;        
     }
    };

#### 解答（C++）牛X解法: 整数中有几个1就循环几次

    # -*- coding:utf-8 -*-
    class Solution:
    public:
     int  NumberOf1(int n) {
		 int count=0;
		 while(n)
		 {
			++count;
			n=(n-1)&n;//n与n-1位与运算，相当于把n最右边的1变成0,之后的全为0.如：1100&1011->1000 
		 }
		 return count;        
     }
    };



#### 笔记: ####
>位运算不太熟悉，看了会书才做的。解题思路也是参考书上的，第二种方法有点难。书上还有一种罪初级的解法（n&1相当于n%2==1，但是位运算效率高多了），以此来判断末位是否为1；迭代，每次对n右移运算。这种方法碰到负数会陷入死循环。
>第一种常规解法，依此判断n的最低位是否为1，次低位是否为1...
>第二种解法有点开脑洞了，需要想到一个trick，一个整数（n）与这个整数减去一（n-1）做与运算相当于把整数最右边的1变成0.因此，有多少个1就执行多少次这个操作（见代码）。

#### AC ####
![](http://i.imgur.com/7lgGrRT.png)

